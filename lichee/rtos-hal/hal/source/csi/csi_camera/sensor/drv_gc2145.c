/**
  * @file  drv_gc2145.c
  * @author  XRADIO IOT WLAN Team
  */

/*
 * Copyright (C) 2017 XRADIO TECHNOLOGY CO., LTD. All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *    1. Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *    2. Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the
 *       distribution.
 *    3. Neither the name of XRADIO TECHNOLOGY CO., LTD. nor the names of
 *       its contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "sunxi_hal_twi.h"

#include "sensor_helper.h"

#define MCLK              (24*1000*1000)
#define VREF_POL          MBUS_VSYNC_ACTIVE_HIGH
#define HREF_POL          MBUS_HSYNC_ACTIVE_HIGH
#define CLK_POL           MBUS_PCLK_SAMPLE_RISING

#define ADDR_WIDTH        TWI_BITS_8
#define DATA_WIDTH        TWI_BITS_8

#define GC2145_SCCB_ID			0x3c  // GC2145 ID 0x3c
#define GC2145_CHIP_ID			0x2145
#define GC2145_IIC_CLK_FREQ		100000

#define SENSOR_NAME "gc2145"

static sensor_private gsensor_private;

static sensor_private *sensor_getpriv()
{
	return &gsensor_private;
}

//#define WIN_MODE_QVGA
//#define SUBSAMPLE_1_2

static struct regval_list gc2145_init_reg_tbl[]=
{
	{0xfe, 0xf0},
	{0xfe, 0xf0},
	{0xfe, 0xf0},
	{0xfc, 0x06},
	{0xf6, 0x00},
	{0xf7, 0x1d},
	{0xf8, 0x84},
	{0xfa, 0x00},
	{0xf9, 0xfe},
	{0xf2, 0x00},
	{0xfe, 0x00},
//	{0x8c, 0x0c},  // test colorbar
	{0x03, 0x04},
	{0x04, 0x00},
	{0x09, 0x00},
	{0x0a, 0x00},
	{0x0b, 0x00},
	{0x0c, 0x00},
	{0x0d, 0x04},
	{0x0e, 0xc0},
	{0x0f, 0x06},
	{0x10, 0x52},
	{0x12, 0x2e},
	{0x17, 0x14},
	{0x18, 0x22},
	{0x19, 0x0f},
	{0x1a, 0x01},
	{0x1b, 0x4b},
	{0x1c, 0x07},
	{0x1d, 0x10},
	{0x1e, 0x88},
	{0x1f, 0x78},
	{0x20, 0x03},
	{0x21, 0x40},
	{0x22, 0xf0},
	{0x24, 0x16},
	{0x25, 0x01},
	{0x26, 0x10},
	{0x2d, 0x60},
	{0x30, 0x01},
	{0x31, 0x90},
	{0x33, 0x06},
	{0x34, 0x01},
	{0x80, 0xff},
	{0x81, 0x24},
	{0x82, 0xfa},
	{0x83, 0x00},
	{0x84, 0x02},
	{0x86, 0x07},
	{0x88, 0x03},
	{0x89, 0x03},
	{0x85, 0x30},
	{0x8a, 0x00},
	{0x8b, 0x00},
	{0xb0, 0x55},
	{0xc3, 0x00},
	{0xc4, 0x80},
	{0xc5, 0x90},
	{0xc6, 0x38},
	{0xc7, 0x40},
	{0xec, 0x06},
	{0xed, 0x04},
	{0xee, 0x60},
	{0xef, 0x90},
//	{0xb6, 0x01},
	{0xb6, 0x00},  // close aec
	{0x90, 0x01},
	{0x91, 0x00},
	{0x92, 0x00},
	{0x93, 0x00},
	{0x94, 0x00},
	{0x95, 0x04},
	{0x96, 0xb0},
	{0x97, 0x06},
	{0x98, 0x40},
	{0x18, 0x02},
	{0x40, 0x42},
	{0x41, 0x00},
	{0x43, 0x54},
	{0x5e, 0x00},
	{0x5f, 0x00},
	{0x60, 0x00},
	{0x61, 0x00},
	{0x62, 0x00},
	{0x63, 0x00},
	{0x64, 0x00},
	{0x65, 0x00},
	{0x66, 0x20},
	{0x67, 0x20},
	{0x68, 0x20},
	{0x69, 0x20},
	{0x76, 0x00},
	{0x6a, 0x02},
	{0x6b, 0x02},
	{0x6c, 0x02},
	{0x6d, 0x02},
	{0x6e, 0x02},
	{0x6f, 0x02},
	{0x70, 0x02},
	{0x71, 0x02},
	{0x76, 0x00},
	{0x72, 0xf0},
	{0x7e, 0x3c},
	{0x7f, 0x00},
	{0xfe, 0x02},
	{0x48, 0x15},
	{0x49, 0x00},
	{0x4b, 0x0b},
	{0xfe, 0x00},
	{0xfe, 0x01},
	{0x01, 0x04},
	{0x02, 0xc0},
	{0x03, 0x04},
	{0x04, 0x90},
	{0x05, 0x30},
	{0x06, 0x90},
	{0x07, 0x20},
	{0x08, 0x70},
	{0x09, 0x00},
	{0x0a, 0xc2},
	{0x0b, 0x11},
	{0x0c, 0x10},
	{0x13, 0x30},
	{0x17, 0x00},
	{0x1c, 0x11},
	{0x1e, 0x61},
	{0x1f, 0x30},
	{0x20, 0x40},
	{0x22, 0x80},
	{0x23, 0x20},
	{0xfe, 0x02},
	{0x0f, 0x04},
	{0xfe, 0x01},
	{0x12, 0x00},
	{0x15, 0x50},
	{0x10, 0x31},
	{0x3e, 0x28},
	{0x3f, 0xe0},
	{0x40, 0xe0},
	{0x41, 0x0f},
	{0xfe, 0x02},
	{0x90, 0x6c},
	{0x91, 0x03},
	{0x92, 0xc8},
	{0x94, 0x66},
	{0x95, 0xb5},
	{0x97, 0x64},
	{0xa2, 0x11},
	{0xfe, 0x00},
	{0xfe, 0x02},
	{0x80, 0xc1},
	{0x81, 0x08},
	{0x82, 0x08},
	{0x83, 0x05},
	{0x84, 0x0a},
	{0x86, 0x50},
	{0x87, 0x30},
	{0x88, 0x15},
	{0x89, 0x80},
	{0x8a, 0x60},
	{0x8b, 0x30},
	{0xfe, 0x01},
	{0x21, 0x14},
	{0xfe, 0x02},
	{0xa3, 0x40},
	{0xa4, 0x20},
	{0xa5, 0x40},
	{0xa6, 0x80},
	{0xab, 0x40},
	{0xae, 0x0c},
	{0xb3, 0x34},
	{0xb4, 0x44},
	{0xb6, 0x38},
	{0xb7, 0x02},
	{0xb9, 0x30},
	{0x3c, 0x08},
	{0x3d, 0x30},
	{0x4b, 0x0d},
	{0x4c, 0x20},
	{0xfe, 0x00},
	{0xfe, 0x02},
	{0x10, 0x10},
	{0x11, 0x15},
	{0x12, 0x1a},
	{0x13, 0x1f},
	{0x14, 0x2c},
	{0x15, 0x39},
	{0x16, 0x45},
	{0x17, 0x54},
	{0x18, 0x69},
	{0x19, 0x7d},
	{0x1a, 0x8f},
	{0x1b, 0x9d},
	{0x1c, 0xa9},
	{0x1d, 0xbd},
	{0x1e, 0xcd},
	{0x1f, 0xd9},
	{0x20, 0xe3},
	{0x21, 0xea},
	{0x22, 0xef},
	{0x23, 0xf5},
	{0x24, 0xf9},
	{0x25, 0xff},
	{0xfe, 0x02},
	{0x26, 0x0f},
	{0x27, 0x14},
	{0x28, 0x19},
	{0x29, 0x1e},
	{0x2a, 0x27},
	{0x2b, 0x33},
	{0x2c, 0x3b},
	{0x2d, 0x45},
	{0x2e, 0x59},
	{0x2f, 0x69},
	{0x30, 0x7c},
	{0x31, 0x89},
	{0x32, 0x98},
	{0x33, 0xae},
	{0x34, 0xc0},
	{0x35, 0xcf},
	{0x36, 0xda},
	{0x37, 0xe2},
	{0x38, 0xe9},
	{0x39, 0xf3},
	{0x3a, 0xf9},
	{0x3b, 0xff},
	{0xfe, 0x02},
	{0xd1, 0x30},
	{0xd2, 0x30},
	{0xd3, 0x45},
	{0xdd, 0x14},
	{0xde, 0x86},
	{0xed, 0x01},
	{0xee, 0x28},
	{0xef, 0x30},
	{0xd8, 0xd8},
	{0xfe, 0x01},
	{0xc2, 0x1a},
	{0xc3, 0x0b},
	{0xc4, 0x0e},
	{0xc8, 0x20},
	{0xc9, 0x0c},
	{0xca, 0x12},
	{0xbc, 0x41},
	{0xbd, 0x1f},
	{0xbe, 0x29},
	{0xb6, 0x48},
	{0xb7, 0x22},
	{0xb8, 0x28},
	{0xc5, 0x04},
	{0xc6, 0x00},
	{0xc7, 0x00},
	{0xcb, 0x12},
	{0xcc, 0x00},
	{0xcd, 0x08},
	{0xbf, 0x14},
	{0xc0, 0x00},
	{0xc1, 0x10},
	{0xb9, 0x0f},
	{0xba, 0x00},
	{0xbb, 0x00},
	{0xaa, 0x0a},
	{0xab, 0x00},
	{0xac, 0x00},
	{0xad, 0x09},
	{0xae, 0x00},
	{0xaf, 0x02},
	{0xb0, 0x04},
	{0xb1, 0x00},
	{0xb2, 0x00},
	{0xb3, 0x03},
	{0xb4, 0x00},
	{0xb5, 0x02},
	{0xd0, 0x42},
	{0xd1, 0x00},
	{0xd2, 0x00},
	{0xd6, 0x47},
	{0xd7, 0x07},
	{0xd8, 0x00},
	{0xd9, 0x34},
	{0xda, 0x13},
	{0xdb, 0x00},
	{0xd3, 0x2b},
	{0xd4, 0x18},
	{0xd5, 0x10},
	{0xa4, 0x00},
	{0xa5, 0x00},
	{0xa6, 0x77},
	{0xa7, 0x77},
	{0xa8, 0x77},
	{0xa9, 0x77},
	{0xa1, 0x80},
	{0xa2, 0x80},

	{0xfe, 0x01},
	{0xdf, 0x00},
	{0xdc, 0x80},
	{0xdd, 0x30},
	{0xe0, 0x6b},
	{0xe1, 0x70},
	{0xe2, 0x6b},
	{0xe3, 0x70},
	{0xe6, 0xa0},
	{0xe7, 0x60},
	{0xe8, 0xa0},
	{0xe9, 0x60},
	{0xfe, 0x00},
	{0xfe, 0x01},
	{0x4f, 0x00},
	{0x4f, 0x00},
	{0x4b, 0x01},
	{0x4f, 0x00},
	{0x4c, 0x01},
	{0x4d, 0x71},
	{0x4e, 0x01},
	{0x4c, 0x01},
	{0x4d, 0x91},
	{0x4e, 0x01},
	{0x4c, 0x01},
	{0x4d, 0x70},
	{0x4e, 0x01},
	{0x4c, 0x01},
	{0x4d, 0x90},
	{0x4e, 0x02},
	{0x4c, 0x01},
	{0x4d, 0xb0},
	{0x4e, 0x02},
	{0x4c, 0x01},
	{0x4d, 0x8f},
	{0x4e, 0x02},
	{0x4c, 0x01},
	{0x4d, 0x6f},
	{0x4e, 0x02},
	{0x4c, 0x01},
	{0x4d, 0xaf},
	{0x4e, 0x02},
	{0x4c, 0x01},
	{0x4d, 0xd0},
	{0x4e, 0x02},
	{0x4c, 0x01},
	{0x4d, 0xf0},
	{0x4e, 0x02},
	{0x4c, 0x01},
	{0x4d, 0xcf},
	{0x4e, 0x02},
	{0x4c, 0x01},
	{0x4d, 0xef},
	{0x4e, 0x02},
	{0x4c, 0x01},
	{0x4d, 0x6e},
	{0x4e, 0x03},
	{0x4c, 0x01},
	{0x4d, 0x8e},
	{0x4e, 0x03},
	{0x4c, 0x01},
	{0x4d, 0xae},
	{0x4e, 0x03},
	{0x4c, 0x01},
	{0x4d, 0xce},
	{0x4e, 0x03},
	{0x4c, 0x01},
	{0x4d, 0xee},
	{0x4e, 0x03},
	{0x4c, 0x01},
	{0x4d, 0x6d},
	{0x4e, 0x03},
	{0x4c, 0x01},
	{0x4d, 0x8d},
	{0x4e, 0x03},
	{0x4c, 0x01},
	{0x4d, 0xad},
	{0x4e, 0x03},
	{0x4c, 0x01},
	{0x4d, 0xcd},
	{0x4e, 0x03},
	{0x4c, 0x01},
	{0x4d, 0xed},
	{0x4e, 0x03},
	{0x4c, 0x01},
	{0x4d, 0x6c},
	{0x4e, 0x03},
	{0x4c, 0x01},
	{0x4d, 0x8c},
	{0x4e, 0x03},
	{0x4c, 0x01},
	{0x4d, 0xac},
	{0x4e, 0x03},
	{0x4c, 0x01},
	{0x4d, 0xcc},
	{0x4e, 0x03},
	{0x4c, 0x01},
	{0x4d, 0xec},
	{0x4e, 0x03},
	{0x4c, 0x01},
	{0x4d, 0x6b},
	{0x4e, 0x03},
	{0x4c, 0x01},
	{0x4d, 0x8b},
	{0x4e, 0x03},
	{0x4c, 0x01},
	{0x4d, 0x8a},
	{0x4e, 0x03},
	{0x4c, 0x01},
	{0x4d, 0xaa},
	{0x4e, 0x04},
	{0x4c, 0x01},
	{0x4d, 0xab},
	{0x4e, 0x04},
	{0x4c, 0x01},
	{0x4d, 0xcb},
	{0x4e, 0x04},
	{0x4c, 0x01},
	{0x4d, 0xa9},
	{0x4e, 0x04},
	{0x4c, 0x01},
	{0x4d, 0xca},
	{0x4e, 0x04},
	{0x4c, 0x01},
	{0x4d, 0xc9},
	{0x4e, 0x04},
	{0x4c, 0x01},
	{0x4d, 0x8a},
	{0x4e, 0x04},
	{0x4c, 0x01},
	{0x4d, 0x89},
	{0x4e, 0x04},
	{0x4c, 0x01},
	{0x4d, 0xeb},
	{0x4e, 0x05},
	{0x4c, 0x02},
	{0x4d, 0x0b},
	{0x4e, 0x05},
	{0x4c, 0x02},
	{0x4d, 0x0c},
	{0x4e, 0x05},
	{0x4c, 0x02},
	{0x4d, 0x2c},
	{0x4e, 0x05},
	{0x4c, 0x02},
	{0x4d, 0x2b},
	{0x4e, 0x05},
	{0x4c, 0x01},
	{0x4d, 0xea},
	{0x4e, 0x05},
	{0x4c, 0x02},
	{0x4d, 0x0a},
	{0x4e, 0x05},
	{0x4c, 0x02},
	{0x4d, 0x8b},
	{0x4e, 0x06},
	{0x4c, 0x02},
	{0x4d, 0x2a},
	{0x4e, 0x06},
	{0x4c, 0x02},
	{0x4d, 0x4a},
	{0x4e, 0x06},
	{0x4c, 0x02},
	{0x4d, 0x6a},
	{0x4e, 0x06},
	{0x4c, 0x02},
	{0x4d, 0x8a},
	{0x4e, 0x06},
	{0x4c, 0x02},
	{0x4d, 0xaa},
	{0x4e, 0x06},
	{0x4c, 0x02},
	{0x4d, 0x09},
	{0x4e, 0x06},
	{0x4c, 0x02},
	{0x4d, 0x29},
	{0x4e, 0x06},
	{0x4c, 0x02},
	{0x4d, 0x49},
	{0x4e, 0x06},
	{0x4c, 0x02},
	{0x4d, 0x69},
	{0x4e, 0x06},
	{0x4c, 0x02},
	{0x4d, 0xcc},
	{0x4e, 0x07},
	{0x4c, 0x02},
	{0x4d, 0xca},
	{0x4e, 0x07},
	{0x4c, 0x02},
	{0x4d, 0xa9},
	{0x4e, 0x07},
	{0x4c, 0x02},
	{0x4d, 0xc9},
	{0x4e, 0x07},
	{0x4c, 0x02},
	{0x4d, 0xe9},
	{0x4e, 0x07},

	{0x4f, 0x01},
	{0x50, 0x80},
	{0x51, 0xa8},
	{0x52, 0x47},
	{0x53, 0x38},
	{0x54, 0xc7},
	{0x56, 0x0e},
	{0x58, 0x08},
	{0x5b, 0x00},
	{0x5c, 0x74},
	{0x5d, 0x8b},
	{0x61, 0xdb},
	{0x62, 0xb8},
	{0x63, 0x86},
	{0x64, 0xc0},
	{0x65, 0x04},
	{0x67, 0xa8},
	{0x68, 0xb0},
	{0x69, 0x00},
	{0x6a, 0xa8},
	{0x6b, 0xb0},
	{0x6c, 0xaf},
	{0x6d, 0x8b},
	{0x6e, 0x50},
	{0x6f, 0x18},
	{0x73, 0xe0},
	{0x70, 0x0d},
	{0x71, 0x68},
	{0x72, 0x81},
	{0x74, 0x01},
	{0x75, 0x01},
	{0x7f, 0x0c},
	{0x76, 0x70},
	{0x77, 0x58},
	{0x78, 0xa0},
	{0x79, 0x5e},
	{0x7a, 0x54},
	{0x7b, 0x55},
	{0xfe, 0x00},
	{0xfe, 0x02},
	{0xc0, 0x01},
	{0xC1, 0x44},
	{0xc2, 0xF4},
	{0xc3, 0x02},
	{0xc4, 0xf2},
	{0xc5, 0x44},
	{0xc6, 0xf8},
	{0xC7, 0x50},
	{0xc8, 0xf2},
	{0xc9, 0x00},
	{0xcA, 0xE0},
	{0xcB, 0x45},
	{0xcC, 0xec},
	{0xCd, 0x45},
	{0xce, 0xf0},
	{0xcf, 0x00},
	{0xe3, 0xf0},
	{0xe4, 0x45},
	{0xe5, 0xe8},
	{0xfe, 0x00},
	{0x05, 0x01},
	{0x06, 0x56},
	{0x07, 0x00},  // vb = 50
	{0x08, 0x32},
//	{0x07, 0x05},  // vb = 1280
//	{0x08, 0x00},
	{0xfe, 0x01},
	{0x25, 0x00},
	{0x26, 0xfa},
	{0x27, 0x04},
	{0x28, 0xe2},
	{0x29, 0x05},
	{0x2a, 0xdc},
	{0x2b, 0x06},
	{0x2c, 0xd6},
	{0x2d, 0x0b},
	{0x2e, 0xb8},
	{0xfe, 0x00},
	{0xfe, 0x00},
	{0xfa, 0x00},
	{0xfd, 0x01},
	{0xfe, 0x00},
	{0x99, 0x11},
	{0x9a, 0x06},
	{0x9b, 0x00},
	{0x9c, 0x00},
	{0x9d, 0x00},
	{0x9e, 0x00},
	{0x9f, 0x00},
	{0xa0, 0x00},
	{0xa1, 0x00},
	{0xa2, 0x00},
	{0x90, 0x01},
	{0x91, 0x00},
	{0x92, 0x00},
	{0x93, 0x00},
	{0x94, 0x00},
	{0x95, 0x02},
	{0x96, 0x58},
	{0x97, 0x03},
	{0x98, 0x20},
	{0xfe, 0x00},
	{0xec, 0x01},
	{0xed, 0x02},
	{0xee, 0x30},
	{0xef, 0x48},
	{0xfe, 0x01},
	{0x74, 0x00},
	{0xfe, 0x01},
	{0x01, 0x04},
	{0x02, 0x60},
	{0x03, 0x02},
	{0x04, 0x48},
	{0x05, 0x18},
	{0x06, 0x4c},
	{0x07, 0x14},
	{0x08, 0x36},
	{0x0a, 0xc0},
	{0x21, 0x14},
	{0xfe, 0x00},
	{0xfe, 0x00},
	{0xf2, 0x0f},
	{0x18, 0x22},
	{0xfe, 0x02},
	{0x40, 0xbf},
	{0x46, 0xcf},
	{0xfe, 0x00},

	/* 1600X1200 UXGA capture */
	{0xfe, 0x00},
	{0xb6, 0x00},
	{0xfa, 0x11},  // clk_div / 2
//	{0xfa, 0x00},  // not clk_div, 1600 1200 20fps
	{0xfd, 0x00},
	{0xfe, 0x00},
	{0xb6, 0x00},
	{0x99, 0x11},
	{0x9a, 0x06},
	{0x9b, 0x00},
	{0x9c, 0x00},
	{0x9d, 0x00},
	{0x9e, 0x00},
	{0x9f, 0x00},
	{0xa0, 0x00},
	{0xa1, 0x00},
	{0xa2, 0x00},
	{0x90, 0x01},
	{0x91, 0x00},
	{0x92, 0x00},
	{0x93, 0x00},
	{0x94, 0x00},
	{0x95, 0x04},
	{0x96, 0xb0},
	{0x97, 0x06},
	{0x98, 0x40},
	{0xfe, 0x00},
	{0xec, 0x02},
	{0xed, 0x04},
	{0xee, 0x60},
	{0xef, 0x90},
	{0xfe, 0x01},
	{0x74, 0x01},
	{0xfe, 0x01},
	{0x01, 0x08},
	{0x02, 0xc0},
	{0x03, 0x04},
	{0x04, 0x90},
	{0x05, 0x30},
	{0x06, 0x98},
	{0x07, 0x28},
	{0x08, 0x6c},
	{0x0a, 0xc2},
	{0x21, 0x15},
	{0xfe, 0x00},

};

/**
  * @brief Seclet the light mode.
  * @note This function is used to set the light mode for camera.
  *           The appropriate mode helps to improve the shooting effect.
  * @param light_mode: light mode.
  * @retval None
  */
void GC2145_SetLightMode(SENSOR_LightMode light_mode)
{
	sensor_private *priv = sensor_getpriv();
	uint8_t reg13val = 0XE7, reg01val = 0, reg02val = 0;
	switch(light_mode) {
	case LIGHT_AUTO:
		reg13val = 0XE7;
		reg01val = 0;
		reg02val = 0;
		break;
	case LIGHT_SUNNY:
		reg13val = 0XE5;
		reg01val = 0X5A;
		reg02val = 0X5C;
		break;
	case LIGHT_COLUDY:
		reg13val = 0XE5;
		reg01val = 0X58;
		reg02val = 0X60;
		break;
	case LIGHT_OFFICE:
		reg13val = 0XE5;
		reg01val = 0X84;
		reg02val = 0X4c;
		break;
	case LIGHT_HOME:
		reg13val = 0XE5;
		reg01val = 0X96;
		reg02val = 0X40;
		break;
	}
	sensor_write(priv, 0X13, reg13val);
	sensor_write(priv, 0X01, reg01val);
	sensor_write(priv, 0X02, reg02val);
}

/**
  * @brief Set the color saturation for camera.
  * @param sat: The color saturation.
  * @retval None
  */
void GC2145_SetColorSaturation(SENSOR_ColorSaturation sat)
{
	sensor_private *priv = sensor_getpriv();
	uint8_t reg4f5054val = 0X80, reg52val = 0X22, reg53val = 0X5E;

	switch (sat) {
	case COLOR_SATURATION_0://-2
		reg4f5054val = 0X40;
		reg52val = 0X11;
		reg53val = 0X2F;
		break;
	case COLOR_SATURATION_1://-1
		reg4f5054val = 0X66;
		reg52val = 0X1B;
		reg53val = 0X4B;
		break;
	case COLOR_SATURATION_2:
		reg4f5054val = 0X80;
		reg52val = 0X22;
		reg53val = 0X5E;
		break;
		case COLOR_SATURATION_3:
		reg4f5054val = 0X99;
		reg52val = 0X28;
		reg53val = 0X71;
		break;
	case COLOR_SATURATION_4:
		reg4f5054val = 0XC0;
		reg52val = 0X33;
		reg53val = 0X8D;
		break;
	}

	sensor_write(priv, 0X4F, reg4f5054val);
	sensor_write(priv, 0X50, reg4f5054val);
	sensor_write(priv, 0X51, 0X00);
	sensor_write(priv, 0X52, reg52val);
	sensor_write(priv, 0X53, reg53val);
	sensor_write(priv, 0X54, reg4f5054val);

}

/**
  * @brief Set the sensitivity for camera.
  * @param brihgt: The brightness value.
  * @retval None
  */
void GC2145_SetBrightness(SENSOR_Brightness bright)
{
	sensor_private *priv = sensor_getpriv();
	uint8_t reg55val = 0X00;

	switch (bright) {
	case BRIGHT_0:		//-2
		reg55val = 0XB0;
		break;
	case BRIGHT_1:
		reg55val = 0X98;
			break;
	case BRIGHT_2:
		reg55val = 0X00;
		break;
	case BRIGHT_3:
		reg55val = 0X18;
		break;
	case BRIGHT_4:
		reg55val = 0X30;
		break;
	}

	sensor_write(priv, 0X55,reg55val);
}

/**
  * @brief Set the contarst for camera.
  * @param contrast: The contrast value.
  * @retval None
  */
void GC2145_SetContrast(SENSOR_Contarst contrast)
{
	sensor_private *priv = sensor_getpriv();
	uint8_t reg56val = 0X40;

	switch (contrast) {
	case CONTARST_0:	//-2
		reg56val = 0X30;
		break;
	case CONTARST_1:
		reg56val = 0X38;
		break;
	case CONTARST_2:
		reg56val = 0X40;
		break;
	case CONTARST_3:
		reg56val = 0X50;
		break;
	case CONTARST_4:
		reg56val = 0X60;
		break;
	}
	sensor_write(priv, 0X56,reg56val);
}

/**
  * @brief Set the effects for camera.
  * @param eft: effects.
  * @retval None
  */
void GC2145_SetSpecialEffects(SENSOR_SpecailEffects eft)
{
	sensor_private *priv = sensor_getpriv();
	uint8_t reg3aval = 0X04;
	uint8_t reg67val = 0XC0;
	uint8_t reg68val = 0X80;

	switch (eft) {
	case IMAGE_NOMAL:	//nomal
		reg3aval = 0X04;
		reg67val = 0XC0;
		reg68val = 0X80;
		break;
	case IMAGE_NEGATIVE:
		reg3aval = 0X24;
		reg67val = 0X80;
		reg68val = 0X80;
		break;
	case IMAGE_BLACK_WHITE:
		reg3aval = 0X14;
		reg67val = 0X80;
		reg68val = 0X80;
		break;
	case IMAGE_SLANT_RED:
		reg3aval = 0X14;
		reg67val = 0Xc0;
		reg68val = 0X80;
		break;
	case IMAGE_SLANT_GREEN:
		reg3aval = 0X14;
		reg67val = 0X40;
		reg68val = 0X40;
		break;
	case IMAGE_SLANT_BLUE:
		reg3aval = 0X14;
		reg67val = 0X80;
		reg68val = 0XC0;
		break;
	case IMAGE_VINTAGE:
		reg3aval = 0X14;
		reg67val = 0XA0;
		reg68val = 0X40;
		break;
	}

	sensor_write(priv, 0X3A, reg3aval);
	sensor_write(priv, 0X68, reg67val);
	sensor_write(priv, 0X67, reg68val);
}

/**
  * @brief Set the window for camera.
  * @param sx: Starting coordinates.
  * @param sy: Starting coordinates.
  * @param width: Window width.
  * @param height: Window height.
  * @retval None
  */
void GC2145_SetWindow(uint16_t sx, uint16_t sy, uint16_t width, uint16_t height)
{
	sensor_private *priv = sensor_getpriv();
	uint16_t endx;
	uint16_t endy;
	uint8_t temp;

	endx = sx + width * 2;		//V*2
	endy = sy + height * 2;
	if (endy > 784)
	endy -= 784;

	sensor_read(priv, 0X03, (uint16_t *)&temp);
	temp &= 0XF0;
	temp |= ((endx & 0X03) << 2) | (sx & 0X03);
	sensor_write(priv, 0X03, temp);
	sensor_write(priv, 0X19, sx>>2);
	sensor_write(priv, 0X1A, endx>>2);
	sensor_read(priv, 0X32, (uint16_t *)&temp);
	temp &= 0XC0;
	temp |= ((endy & 0X07) << 3) | (sy&0X07);
	sensor_write(priv, 0X32, temp);
	sensor_write(priv, 0X17, sy >> 3);
	sensor_write(priv, 0X18, endy >> 3);
}

//(140,16,640,480) is good for VGA
//(272,16,320,240) is good for QVGA
/* config_GC2145_window */
void GC2145_ConfigWindow(unsigned int startx,unsigned int starty,unsigned int width, unsigned int height)
{
	sensor_private *priv = sensor_getpriv();
	unsigned int endx;
	unsigned int endy;// "v*2"????
	unsigned char temp_reg1, temp_reg2;
	unsigned char temp=0;

	endx=(startx+width*2)%784;
	endy=(starty+height*2);// "v*2"????

	sensor_read(priv, 0x32, (uint16_t *)&temp_reg2);
	temp_reg2 &= 0xc0;

	sensor_read(priv, 0x03, (uint16_t *)&temp_reg1);
	temp_reg1 &= 0xf0;

	// Horizontal
	temp = temp_reg2|((endx&0x7)<<3)|(startx&0x7);
	sensor_write(priv, 0x32, temp);
	temp = (startx&0x7F8)>>3;
	sensor_write(priv, 0x17, temp);
	temp = (endx&0x7F8)>>3;
	sensor_write(priv, 0x18, temp);

	// Vertical
	temp = temp_reg1|((endy&0x3)<<2)|(starty&0x3);
	sensor_write(priv, 0x03, temp);
	temp = starty>>2;
	sensor_write(priv, 0x19, temp);
	temp = endy>>2;
	sensor_write(priv, 0x1A, temp);
}

void GC2145_SetPixelOutFmt(SENSOR_PixelOutFmt pixel_out_fmt)
{
	sensor_private *priv = sensor_getpriv();

	switch (pixel_out_fmt) {
	case YUV422_UYVY:
		sensor_write(priv, 0x24, 0xa0);
		break;
	case YUV422_VYUY:
		sensor_write(priv, 0x24, 0xa1);
		break;
	case YUV422_YUYV:
		sensor_write(priv, 0x24, 0xa2);
		break;
	case YUV422_YVYU:
		sensor_write(priv, 0x24, 0xa3);
		break;
	case RGB565:
		sensor_write(priv, 0x24, 0xa6);
		break;
	default:
		sensor_err("GC2145:untest pixel out fmt %d\n", pixel_out_fmt);
		break;
	}
}

/**
  * @brief Init the io for ctrl the camera power.
  * @param cfg: The io info.
  * @retval None
  */
#if 0
static void GC2145_InitPower(SENSOR_PowerCtrlCfg *cfg)
{
    GPIO_InitParam param;
    param.driving = GPIO_DRIVING_LEVEL_1;
    param.mode = GPIOx_Pn_F1_OUTPUT;
    param.pull = GPIO_PULL_NONE;

    HAL_GPIO_Init(cfg->Pwdn_Port, cfg->Pwdn_Pin, &param);
    HAL_GPIO_Init(cfg->Reset_Port, cfg->Reset_Pin, &param);

    HAL_GPIO_WritePin(cfg->Pwdn_Port, cfg->Pwdn_Pin, GPIO_PIN_LOW);
    HAL_GPIO_WritePin(cfg->Reset_Port, cfg->Reset_Pin, GPIO_PIN_LOW);
    hal_msleep(3);
    HAL_GPIO_WritePin(cfg->Reset_Port, cfg->Reset_Pin, GPIO_PIN_HIGH);
    hal_msleep(100);
}
#endif

static void sensor_power(struct sensor_power_cfg *cfg, unsigned int on)
{
	sensor_private *priv = sensor_getpriv();
	int ret;

	sensor_dbg("[%s:%d]pwdn_pin, reset_pin set!\n", __func__,__LINE__);
	if (on) {
		ret = hal_gpio_pinmux_set_function(cfg->pwdn_pin, GPIO_MUXSEL_OUT);
		ret = hal_gpio_pinmux_set_function(cfg->reset_pin, GPIO_MUXSEL_OUT);
		if (ret)
			sensor_dbg("hal_gpio_pinmux_set_function error!\n");
		ret = hal_gpio_set_driving_level(cfg->pwdn_pin, GPIO_DRIVING_LEVEL1);
		ret = hal_gpio_set_driving_level(cfg->reset_pin, GPIO_DRIVING_LEVEL1);
		if (ret)
			sensor_dbg("hal_gpio_set_driving_level error!\n");
		ret = hal_gpio_set_pull(cfg->pwdn_pin, GPIO_PULL_DOWN_DISABLED);
		ret = hal_gpio_set_pull(cfg->reset_pin, GPIO_PULL_DOWN_DISABLED);
		if (ret)
			sensor_dbg("hal_gpio_set_pull error!\n");

		csi_set_mclk_rate(priv, MCLK);
		csi_set_mclk(priv, 1);
		hal_msleep(100);

		hal_gpio_set_data(cfg->pwdn_pin, GPIO_DATA_LOW);
		hal_msleep(30);
		hal_gpio_set_data(cfg->reset_pin, GPIO_DATA_HIGH);
		hal_msleep(100);
	} else {
		hal_gpio_set_data(cfg->pwdn_pin, GPIO_DATA_HIGH);
		hal_gpio_set_data(cfg->reset_pin, GPIO_DATA_LOW);
		csi_set_mclk(priv, 0);
		hal_msleep(100);
		sensor_dbg("there is no deinit gpio!!!!\n");
	}

	return HAL_OK;
}

#if 0
static void GC2145_DeInitPower(SENSOR_PowerCtrlCfg *cfg)
{
    HAL_GPIO_WritePin(cfg->Pwdn_Port, cfg->Pwdn_Pin, GPIO_PIN_HIGH);
    HAL_GPIO_WritePin(cfg->Reset_Port, cfg->Reset_Pin, GPIO_PIN_LOW);
    hal_msleep(3);
    HAL_GPIO_DeInit(cfg->Pwdn_Port, cfg->Pwdn_Pin);
    HAL_GPIO_DeInit(cfg->Reset_Port, cfg->Reset_Pin);
}
#endif

static HAL_Status gc2145_s_stream(void)
{
	sensor_private *priv = sensor_getpriv();
	uint16_t chip_id = 0;
	uint16_t val = 0;
	uint16_t i = 0;
	int cnt = 0;

/*	while (cnt < 5) {
		sensor_write(priv, 0XFE, 0x80);
		hal_msleep(100);
		cnt++;
	}
*/
	sensor_write(priv, 0XFE, 0x80);
	hal_msleep(100);
	sensor_write(priv, 0XFE, 0x00);
	hal_msleep(100);

	sensor_read(priv, 0xf0, &val);
	chip_id |= (val << 8);
	sensor_read(priv, 0xf1, &val);
	chip_id |= (val);
	sensor_print("V4L2_IDENT_SENSOR = %x\n", chip_id);

	if(chip_id != GC2145_CHIP_ID) {
		sensor_err("GC2145 get chip id wrong 0x%02x\n", chip_id);
		return HAL_ERROR;
	} else {
		sensor_print("GC2145 chip id read success 0x%02x\n", chip_id);
	}

	sensor_write_array(priv, gc2145_init_reg_tbl, ARRAY_SIZE(gc2145_init_reg_tbl));

	sensor_print("GC2145 Init Done \r\n");

	return HAL_OK;
}

HAL_Status hal_gc2145_ioctl(SENSOR_IoctrlCmd attr, uint32_t arg)
{
	switch (attr) {
	case SENSOR_SET_OUTPUT_FMT:
	{
		SENSOR_PixelOutFmt output_fmt;
		output_fmt = *((SENSOR_PixelOutFmt *)arg);
		GC2145_SetPixelOutFmt(output_fmt);
		break;
	}
	default:
		sensor_err("un support camsensor cmd %d\n", attr);
		return HAL_ERROR;
		break;
	}

	return HAL_OK;
}

#ifdef CONFIG_PM
static int sensor_suspend(struct soc_device *dev, enum suspend_state_t state)
{
	sensor_private *priv = (sensor_Private*)dev->platform_data;
	priv->suspend = 1;

	switch (state) {
	case PM_MODE_SLEEP:
	case PM_MODE_STANDBY:
	case PM_MODE_HIBERNATION:
		HAL_GC2145_Suspend();
		break;
	default:
		break;
	}

	return 0;
}

static int sensor_resume(struct soc_device *dev, enum suspend_state_t state)
{
	sensor_private *priv = (sensor_Private*)dev->platform_data;

	switch (state) {
	case PM_MODE_SLEEP:
	case PM_MODE_STANDBY:
	case PM_MODE_HIBERNATION:
		HAL_GC2145_Resume();
		break;
	default:
		break;
	}
	priv->suspend = 0;

	return 0;
}

static const struct soc_device_driver sensor_drv = {
	.name = "sensor",
	.suspend = sensor_suspend,
	.resume = sensor_resume,
};
#endif

struct sensor_win_size hal_gc2145_win_sizes = {
	.width = 640,
	.height = 480,
	.hoffset = 480,
	.voffset = 360,
	.mbus_code = MEDIA_BUS_FMT_YUYV8_2X8,
};

void hal_gc2145_g_mbus_config(unsigned int *flags)
{
	//DC
	*flags = MBUS_SEPARATE_SYNCS | VREF_POL | HREF_POL | CLK_POL;
}

/**
  * @brief Init the GC2145.
  * @retval HAL_Status : The driver status.
  */
HAL_Status hal_gc2145_init(struct sensor_config *cfg)
{
	sensor_private *priv = sensor_getpriv();
	
	priv->twi_port = cfg->twi_port;
	priv->addr_width = ADDR_WIDTH;
	priv->data_width = DATA_WIDTH;
	priv->slave_addr = GC2145_SCCB_ID;
	sensor_twi_init(priv->twi_port, GC2145_SCCB_ID);

#ifdef CONFIG_PM
	if (!priv->suspend) {
		priv->dev.name = "sensor";
		priv->dev.driver = &sensor_drv;
		priv->dev.platform_data = priv;
		pm_register_ops(&priv->dev);
	}
#endif

	sensor_power(&cfg->pwcfg, 1);

	if (gc2145_s_stream() != HAL_OK) {
		sensor_err("GC2145  Init error!!\n");
		return HAL_ERROR;
	}

	sensor_print("GC2145 Init ok!!\n");
	hal_msleep(100);
	return HAL_OK;
}

/**
  * @brief Deinit the GC2145.
  * @retval HAL_Status : The driver status.
  */
void hal_gc2145_deinit(struct sensor_config *cfg)
{
	sensor_private *priv = sensor_getpriv();

#ifdef CONFIG_PM
	if (!priv->suspend)
		pm_unregister_ops(&priv->dev);
#endif

	sensor_power(&cfg->pwcfg, 0);
	sensor_twi_exit(priv->twi_port);
	sensor_dbg("%s line: %d", __func__, __LINE__);

	return HAL_OK;
}

/**
  * @brief Suspend the GC2145.
  * @retval Void.
  */
void hal_gc2145_suspend(void)
{
	sensor_private *priv = sensor_getpriv();
	uint8_t analog_mode1 = 0;
	uint8_t output_en = 0;

	sensor_read(priv, 0x1a, (uint16_t *)&analog_mode1);
	sensor_read(priv, 0x25, (uint16_t *)&output_en);

	analog_mode1 |= 0x1;
	output_en = 0;

	sensor_write(priv, 0x1a, analog_mode1);
	sensor_write(priv, 0x25, output_en);
}

/**
  * @brief Resume the GC2145.
  * @retval Void.
  */
void hal_gc2145_resume(void)
{
	sensor_private *priv = sensor_getpriv();
	uint8_t analog_mode1 = 0;
	uint8_t output_en = 0;

	sensor_read(priv, 0x1a, (uint16_t *)&analog_mode1);
	sensor_read(priv, 0x25, (uint16_t *)&output_en);

	analog_mode1 &= (~0x1);
	output_en = 0xff;

	sensor_write(priv, 0x1a, analog_mode1);
	sensor_write(priv, 0x25, output_en);
}
