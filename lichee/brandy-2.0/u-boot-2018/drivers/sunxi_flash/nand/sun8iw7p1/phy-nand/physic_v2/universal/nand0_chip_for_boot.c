//SPDX-License-Identifier:	GPL-2.0+
/*
 ************************************************************************************************************************
 *                                                      eNand
 *                                           Nand flash driver scan module
 *
 *                             Copyright(C), 2008-2009, SoftWinners Microelectronic Co., Ltd.
 *                                                  All Rights Reserved
 *
 * File Name : nand_chip_for_boot.c
 *
 * Author :
 *
 * Version : v0.1
 *
 * Date : 2013-11-20
 *
 * Description :
 *
 * Others : None at present.
 *
 *
 *
 ************************************************************************************************************************
 */
#define _NCFB0_C_

#include "../nand_physic_inc.h"

#define NDFC_PAGE_TAB_MAGIC "BT0.NTAB"
#define NDFC_PAGE_TAB_HEAD_SIZE (64)
#define STAMP_VALUE 0x5F0A6C39

typedef struct _Boot_file_head {
	__u32 jump_instruction; // one intruction jumping to real code
	__u8 magic[8]; // ="eGON.BT0" or "eGON.BT1",  not C-style string.
	__u32 check_sum; // generated by PC
	__u32 length; // generated by PC
	__u32 pub_head_size; // the size of boot_file_head_t
	__u8 pub_head_vsn[4]; // the version of boot_file_head_t
	__u8 file_head_vsn[4]; // the version of boot0_file_head_t or
	// boot1_file_head_t
	__u8 Boot_vsn[4];      // Boot version
	__u8 eGON_vsn[4];      // eGON version
	__u8 platform[8];      // platform information
} boot_file_head_t;

extern __u32 SECURE_FLAG;

u32 _cal_sum(u32 *mem_base, u32 size)
{
	u32 count, sum;
	u32 *buf;

	count = size >> 2;
	sum   = 0;
	buf   = (__u32 *)mem_base;
	do {
		sum += *buf++;
		sum += *buf++;
		sum += *buf++;
		sum += *buf++;
	} while ((count -= 4) > (4 - 1));

	while (count-- > 0)
		sum += *buf++;

	return sum;
}

__s32 check_sum(__u32 *mem_base, __u32 size)
{
	__u32 *buf;
	__u32 count;
	__u32 src_sum;
	__u32 sum;
	boot_file_head_t *bfh;

	bfh = (boot_file_head_t *)mem_base;

	/* generate check sum */
	src_sum = bfh->check_sum; // get check_sum field from the head of boot0;
	bfh->check_sum =
		STAMP_VALUE; // replace the check_sum field of the boot0 head with STAMP_VALUE

	count = size >> 2; // unit, 4byte
	sum   = 0;
	buf   = (__u32 *)mem_base;
	do {
		sum += *buf++; // calculate check sum
		sum += *buf++;
		sum += *buf++;
		sum += *buf++;
	} while ((count -= 4) > (4 - 1));

	while (count-- > 0)
		sum += *buf++;

	bfh->check_sum =
		src_sum; // restore the check_sum field of the boot0 head

	//msg("sum:0x%x - src_sum:0x%x\n", sum, src_sum);
	if (sum == src_sum)
		return 0; // ok
	else
		return 1; // err
}

int _generate_page_map_tab(__u32 nand_page_size, __u32 copy_cnt, __u32 page_cnt,
			   __u32 *page_addr, __u32 *page_map_tab_addr,
			   __u32 *tab_size)
{
	s32 i, j;
	u32 max_page_cnt;
	u32 checksum	  = 0;
	u8 *magic	     = (u8 *)NDFC_PAGE_TAB_MAGIC;
	u32 *pdst	     = (u32 *)page_map_tab_addr;
	boot_file_head_t *bfh = (boot_file_head_t *)page_map_tab_addr;
	u32 page_tab_size;
	u32 nand_page_cnt;
	u32 c, p;

	if (copy_cnt == 1) {
		if (nand_page_size != 1024) {
			PHY_ERR("_cal_page_map_tab, wrong @nand_page_size, %d\n",
				nand_page_size);
			return -1;
		}

		max_page_cnt = (1024 - NDFC_PAGE_TAB_HEAD_SIZE) / 4;
		if (page_cnt > max_page_cnt) {
			PHY_ERR("_cal_page_map_tab, wrong @page_cnt, %d\n",
				page_cnt);
			return -1;
		}

		// clear to 0x00
		for (i		    = 0; i < 1024 / 4; i++)
			*(pdst + i) = 0x0;

		// set page address
		for (j = 0, i = NDFC_PAGE_TAB_HEAD_SIZE / 4; j < page_cnt;
		     i++, j++)
			*(pdst + i) = page_addr[j];

		// set page table information
		bfh->platform[0] = page_cnt; //entry_cnt
		bfh->platform[1] = 1; //entry_cell_cnt
		bfh->platform[2] = 4; //entry_cell_size, byte

		// set magic
		//msg("page map table magic: ");
		for (i = 0; i < sizeof(bfh->magic); i++) {
			bfh->magic[i] = *(magic + i);
			//msg("%c", bfh->magic[i]);
		}
		//msg("\n");

		// set stamp value
		bfh->check_sum = STAMP_VALUE;

		// cal checksum
		checksum       = _cal_sum((u32 *)page_map_tab_addr, 1024);
		bfh->check_sum = checksum;

		// check
		if (check_sum((__u32 *)page_map_tab_addr, 1024)) {
			PHY_ERR("_cal_page_map_tab, checksum error!\n");
			return -1;
		}

		*tab_size = 1024;

	} else {
		page_tab_size =
			NDFC_PAGE_TAB_HEAD_SIZE + copy_cnt * page_cnt * 4;
		if (page_tab_size % nand_page_size)
			nand_page_cnt = page_tab_size / nand_page_size + 1;
		else
			nand_page_cnt = page_tab_size / nand_page_size;
		page_tab_size	 = nand_page_cnt * nand_page_size;

		/* clear page table memory spare */
		for (i		    = 0; i < page_tab_size / 4; i++)
			*(pdst + i) = 0x0;

		/* set header */
		bfh->length      = page_tab_size;
		bfh->platform[0] = page_cnt; //entry_cnt
		bfh->platform[1] = copy_cnt; //entry_cell_cnt
		bfh->platform[2] = 4; //entry_cell_size, byte
		//PHY_ERR("length: 0x%x, page_cnt: %d, copy: %d, cell_size: %d Byte\n",bfh->length, bfh->platform[0], bfh->platform[1], bfh->platform[2]);

		/* fill page address */
		for (p = 0; p < page_cnt; p++) {
			for (c = 0; c < copy_cnt; c++) {
				i = NDFC_PAGE_TAB_HEAD_SIZE / 4 + p * copy_cnt +
				    c;
				j = c * page_cnt + p; //j = c*(page_cnt+4) + p;
				*(pdst + i) = page_addr[j];
			}
		}

		/* set magic */
		//msg("page map table magic: ");
		for (i = 0; i < sizeof(bfh->magic); i++) {
			bfh->magic[i] = *(magic + i);
			//msg("%c", bfh->magic[i]);
		}
		//msg("\n");

		/* set stamp value */
		bfh->check_sum = STAMP_VALUE;

		/* cal checksum */
		checksum = _cal_sum((u32 *)page_map_tab_addr, page_tab_size);
		bfh->check_sum = checksum;
		//msg("bfh->check_sum: 0x%x\n", bfh->check_sum);

		/* check */
		if (check_sum((__u32 *)page_map_tab_addr, page_tab_size)) {
			PHY_ERR("_cal_page_map_tab, checksum error!\n");
			return -1;
		}

		*tab_size = page_tab_size;
	}

	return 0;
}

int m0_write_boot0_one_pagetab_nonsecure(unsigned char *buf, unsigned int len,
					 unsigned int counter)
{
	int ret;
	__u32 k, j, i, count, count_tab, block;
	__u8 oob_buf[64];
	__u32 tab_size, data_size_per_page;
	__u32 pages_per_block, copies_per_block;
	__u32 page_addr;
	__u32 *pos_data = NULL, *tab = NULL;
	__u8 *data_FF_buf = NULL;
	struct _nand_physic_op_par lnpo;
	struct _nand_chip_info *nci;

	//	oob_buf = (__u8 *)NAND_Malloc(64);
	//	if(oob_buf == NULL) {
	//		PHY_ERR("NAND_Malloc oob_buf fail!\n");
	//		return -1;
	//	}

	PHY_ERR("burn_boot0 page table nonsecure mode\n");

	nci = g_nctri->nci;

	pos_data = (__u32 *)MALLOC(1024);
	if (!pos_data) {
		PHY_ERR(" malloc for pos_data failed.\n");
		goto error;
	}

	tab = (__u32 *)MALLOC(1024);
	if (!tab) {
		PHY_ERR(" malloc for tab failed.\n");
		goto error;
	}

	data_FF_buf = MALLOC(18048);
	if (data_FF_buf == NULL) {
		PHY_ERR("data_FF_buf malloc error!");
		goto error;
	}

	for (i				   = 0; i < (16384 + 1664); i++)
		*((__u8 *)data_FF_buf + i) = 0xFF;

	MEMSET(oob_buf, 0xff, 64);

	nand_get_version(oob_buf);

	data_size_per_page = 1024;
	pages_per_block    = nci->page_cnt_per_blk;
	copies_per_block   = pages_per_block / NAND_BOOT0_PAGE_CNT_PER_COPY_2;

	block = NAND_BOOT0_BLK_START + counter;

	PHY_ERR("block:%x \n", block);

	/*erase block*/
	lnpo.chip  = 0;
	lnpo.block = block;
	lnpo.page  = 0;

	nand_wait_all_rb_ready();

	ret = nci->nand_physic_erase_block(&lnpo);
	if (ret) {
		PHY_ERR("Fail in erasing block %d!\n", lnpo.block);
		//return ret;
	}

	for (j = 0; j < copies_per_block; j++) {
		count_tab = 0;
		for (k = 8; k < NAND_BOOT0_PAGE_CNT_PER_COPY_2; k++) {
			page_addr = block * pages_per_block +
				    j * NAND_BOOT0_PAGE_CNT_PER_COPY_2 + k;
			if (nci->is_lsb_page((page_addr % pages_per_block))) {
				*((__u32 *)pos_data + count_tab) = page_addr;
				count_tab++;
			}
		}
		_generate_page_map_tab(data_size_per_page, 1,
				       len / data_size_per_page, pos_data, tab,
				       &tab_size);

		count = 0;
		for (k = 0; k < NAND_BOOT0_PAGE_CNT_PER_COPY_2; k++) {
			lnpo.chip   = 0;
			lnpo.block  = block;
			lnpo.page   = j * NAND_BOOT0_PAGE_CNT_PER_COPY_2 + k;
			lnpo.sdata  = (void *)oob_buf;
			lnpo.slen   = 64;
			SECURE_FLAG = 0;
			if (nci->is_lsb_page(lnpo.page)) {
				if (k < 8)
					lnpo.mdata = (void *)tab;
				else {
					lnpo.mdata =
						(void *)(buf +
							 count * data_size_per_page);
					count++;
				}
				nand_wait_all_rb_ready();
				if (nci->nand_write_boot0_page(nci, &lnpo) !=
				    0) {
					PHY_ERR("Warning. Fail in writing page %d in block %d.\n",
						lnpo.page, lnpo.block);
				}
				if (count ==
				    (len + data_size_per_page - 1) /
					    data_size_per_page) {
					count = 0;
				}
			}
		}
	}
	nand_wait_all_rb_ready();

	if (pos_data)
		FREE(pos_data, 1024);
	if (tab)
		FREE(tab, 1024);
	if (data_FF_buf)
		FREE(data_FF_buf, 18048);
	return 0;

error:
	if (pos_data)
		FREE(pos_data, 1024);
	if (tab)
		FREE(tab, 1024);
	if (data_FF_buf)
		FREE(data_FF_buf, 18048);
	return -1;
}

int m0_write_boot0_one_pagetab_4k(unsigned char *buf, unsigned int len,
				  unsigned int counter)
{
	__u32 i, k, j, count, block;
	__u8 oob_buf[64];
	// 	__u8 *oob_buf = NULL;
	__u32 tab_size, data_size_per_page;
	__u32 pages_per_block, copies_per_block;
	__u32 page_addr;
	__u32 *pos_data = NULL, *tab = NULL;
	//	__u8 *data_FF_buf=NULL;
	int ret;
	struct _nand_chip_info *nci;
	struct _nand_physic_op_par lnpo;

	//	oob_buf = (__u8 *)NAND_Malloc(64);
	//	if(oob_buf == NULL) {
	//		PHY_ERR("NAND_Malloc oob_buf fail!\n");
	//		return -1;
	//	}

	nci = g_nctri->nci;

	PHY_ERR("burn_boot0_lsb_pagetab_4k mode!\n");

	pos_data = (__u32 *)MALLOC(128 * 4 * BOOT0_MAX_COPY_CNT);
	if (!pos_data) {
		PHY_ERR("burn_boot0_lsb_FF_mode, malloc for pos_data failed.\n");
		goto error;
	}

	tab = (__u32 *)MALLOC(8 * 1024);
	if (!tab) {
		PHY_ERR("burn_boot0_lsb_FF_mode, malloc for tab failed.\n");
		goto error;
	}

	for (i = 0; i < 64; i++)
		oob_buf[i] = 0xff;

	/* get nand driver version */
	nand_get_version(oob_buf);
	if ((oob_buf[0] != 0xff) || (oob_buf[1] != 0x00)) {
		PHY_ERR("get flash driver version error!");
		goto error;
	}

	data_size_per_page = 4096;
	pages_per_block    = nci->page_cnt_per_blk;
	copies_per_block   = pages_per_block / NAND_BOOT0_PAGE_CNT_PER_COPY_2;

	count = 0;
	for (i = NAND_BOOT0_BLK_START;
	     i < (NAND_BOOT0_BLK_START + NAND_BOOT0_BLK_CNT); i++) {
		for (j = 0; j < copies_per_block; j++) {
			for (k = 8; k < NAND_BOOT0_PAGE_CNT_PER_COPY_2; k++) {
				page_addr = i * pages_per_block +
					    j * NAND_BOOT0_PAGE_CNT_PER_COPY_2 +
					    k;
				if (nci->is_lsb_page(
					    (page_addr % pages_per_block))) {
					*((__u32 *)pos_data + count) =
						page_addr;
					count++;
					if (((count %
					      (len / data_size_per_page)) ==
					     0) &&
					    (count != 0))
						break;
				}
			}
		}
	}

	_generate_page_map_tab(data_size_per_page,
			       copies_per_block * NAND_BOOT0_BLK_CNT,
			       len / data_size_per_page, pos_data, tab,
			       &tab_size);

	block = NAND_BOOT0_BLK_START + counter;

	PHY_ERR("pagetab boot0 %x \n", block);

	lnpo.chip  = 0;
	lnpo.block = block;
	lnpo.page  = 0;
	nand_wait_all_rb_ready();

	ret = nci->nand_physic_erase_block(&lnpo);
	if (ret) {
		PHY_ERR("Fail in erasing block %d!\n", lnpo.block);
		//return ret;
	}

	for (j = 0; j < copies_per_block; j++) {
		count = 0;
		for (k = 0; k < NAND_BOOT0_PAGE_CNT_PER_COPY_2; k++) {
			lnpo.chip   = 0;
			lnpo.block  = block;
			lnpo.page   = j * NAND_BOOT0_PAGE_CNT_PER_COPY_2 + k;
			lnpo.sdata  = oob_buf;
			lnpo.slen   = 64;
			SECURE_FLAG = 1;
			if (nci->is_lsb_page(lnpo.page)) {
				if (k < 8)
					lnpo.mdata = (__u8 *)tab;
				else {
					lnpo.mdata =
						(__u8 *)(buf +
							 count * data_size_per_page);
					count++;
				}

				nand_wait_all_rb_ready();
				if (nci->nand_write_boot0_page(nci, &lnpo) !=
				    0) {
					PHY_ERR("Warning. Fail in writing page %d in block %d.\n",
						lnpo.page, lnpo.block);
				}
				if (count ==
				    (len + data_size_per_page - 1) /
					    data_size_per_page) {
					count = 0;
				}
			}
		}
	}

	if (pos_data)
		FREE(pos_data, 128 * 4 * BOOT0_MAX_COPY_CNT);
	if (tab)
		FREE(tab, 8 * 1024);
	//	if(data_FF_buf)
	//		FREE(data_FF_buf,18048);
	return 0;

error:
	if (pos_data)
		FREE(pos_data, 128 * 4 * BOOT0_MAX_COPY_CNT);
	if (tab)
		FREE(tab, 8 * 1024);
	//	if(data_FF_buf)
	//		FREE(data_FF_buf,18048);
	return -1;
}

int m0_write_boot0_one_pagetab_2k(unsigned char *buf, unsigned int len,
				  unsigned int counter)
{
	__u32 i, k, j, count, block;
	__u8 oob_buf[64];
	//	__u8 *oob_buf = NULL;
	__u32 tab_size, data_size_per_page;
	__u32 pages_per_block, copies_per_block;
	__u32 page_addr;
	__u32 *pos_data = NULL, *tab = NULL;
	//	__u8 *data_FF_buf=NULL;
	int ret;
	struct _nand_chip_info *nci;
	struct _nand_physic_op_par lnpo;

	//	oob_buf = (__u8 *)NAND_Malloc(64);
	//	if(oob_buf == NULL) {
	//		PHY_ERR("NAND_Malloc oob_buf fail!\n");
	//		return -1;
	//	}

	nci = g_nctri->nci;

	PHY_ERR("burn_boot0_lsb_pagetab_2k mode!\n");

	pos_data = (__u32 *)MALLOC(128 * 4 * BOOT0_MAX_COPY_CNT);
	if (!pos_data) {
		PHY_ERR("burn_boot0_lsb_FF_mode, malloc for pos_data failed.\n");
		goto error;
	}

	tab = (__u32 *)MALLOC(8 * 1024);
	if (!tab) {
		PHY_ERR("burn_boot0_lsb_FF_mode, malloc for tab failed.\n");
		goto error;
	}


	for (i = 0; i < 64; i++)
		oob_buf[i] = 0xff;

	/* get nand driver version */
	nand_get_version(oob_buf);
	if ((oob_buf[0] != 0xff) || (oob_buf[1] != 0x00)) {
		PHY_ERR("get flash driver version error!");
		goto error;
	}

	data_size_per_page = 2048;
	pages_per_block    = nci->page_cnt_per_blk;
	copies_per_block   = pages_per_block / NAND_BOOT0_PAGE_CNT_PER_COPY_2;

	count = 0;
	for (i = NAND_BOOT0_BLK_START;
	     i < (NAND_BOOT0_BLK_START + NAND_BOOT0_BLK_CNT); i++) {
		for (j = 0; j < copies_per_block; j++) {
			for (k = 8; k < NAND_BOOT0_PAGE_CNT_PER_COPY_2; k++) {
				page_addr = i * pages_per_block +
					    j * NAND_BOOT0_PAGE_CNT_PER_COPY_2 +
					    k;
				if (nci->is_lsb_page(
					    (page_addr % pages_per_block))) {
					*((__u32 *)pos_data + count) =
						page_addr;
					count++;
					if (((count %
					      (len / data_size_per_page)) ==
					     0) &&
					    (count != 0))
						break;
				}
			}
		}
	}

	_generate_page_map_tab(data_size_per_page,
			       copies_per_block * NAND_BOOT0_BLK_CNT,
			       len / data_size_per_page, pos_data, tab,
			       &tab_size);

	block = NAND_BOOT0_BLK_START + counter;

	PHY_ERR("pagetab boot0 %x \n", block);

	lnpo.chip  = 0;
	lnpo.block = block;
	lnpo.page  = 0;
	nand_wait_all_rb_ready();

	ret = nci->nand_physic_erase_block(&lnpo);
	if (ret) {
		PHY_ERR("Fail in erasing block %d!\n", lnpo.block);
		//return ret;
	}

	for (j = 0; j < copies_per_block; j++) {
		count = 0;
		for (k = 0; k < NAND_BOOT0_PAGE_CNT_PER_COPY_2; k++) {
			lnpo.chip   = 0;
			lnpo.block  = block;
			lnpo.page   = j * NAND_BOOT0_PAGE_CNT_PER_COPY_2 + k;
			lnpo.sdata  = oob_buf;
			lnpo.slen   = 64;
			SECURE_FLAG = 1;
			if (nci->is_lsb_page(lnpo.page)) {
				if (k < 8)
					lnpo.mdata = (__u8 *)tab;
				else {
					lnpo.mdata =
						(__u8 *)(buf +
							 count * data_size_per_page);
					count++;
				}

				nand_wait_all_rb_ready();
				if (nci->nand_write_boot0_page(nci, &lnpo) !=
				    0) {
					PHY_ERR("Warning. Fail in writing page %d in block %d.\n",
						lnpo.page, lnpo.block);
				}
				if (count ==
				    (len + data_size_per_page - 1) /
					    data_size_per_page) {
					count = 0;
				}
			}
		}
	}

	if (pos_data)
		FREE(pos_data, 128 * 4 * BOOT0_MAX_COPY_CNT);
	if (tab)
		FREE(tab, 8 * 1024);
	//	if(data_FF_buf)
	//		FREE(data_FF_buf,18048);
	return 0;

error:
	if (pos_data)
		FREE(pos_data, 128 * 4 * BOOT0_MAX_COPY_CNT);
	if (tab)
		FREE(tab, 8 * 1024);
	//	if(data_FF_buf)
	//		FREE(data_FF_buf,18048);
	return -1;
}

int m0_write_boot0_one_1k_mode(unsigned char *buf, unsigned int len,
			       unsigned int counter)
{
	__u32 i, j;
	__u8 oob_buf[64];
	//__u8 *oob_buf = NULL;
	__u32 pages_per_block, blocks_per_copy, start_block, count;
	int ret;
	struct _nand_chip_info *nci;
	struct _nand_physic_op_par lnpo;

	nci = g_nctri->nci;

	//	oob_buf = (__u8 *)NAND_Malloc(64);
	//	if(oob_buf == NULL) {
	//		PHY_ERR("NAND_Malloc oob_buf fail!\n");
	//		return -1;
	//	}

	PHY_ERR("burn_boot0_1k mode!\n");

	for (i		   = 0; i < 64; i++)
		oob_buf[i] = 0xff;

	/* get nand driver version */
	nand_get_version(oob_buf);
	if ((oob_buf[0] != 0xff) || (oob_buf[1] != 0x00)) {
		PHY_ERR("get flash driver version error!");
		goto error;
	}

	pages_per_block = nci->page_cnt_per_blk;

	blocks_per_copy = NAND_BOOT0_PAGE_CNT_PER_COPY_2 / pages_per_block;
	if (NAND_BOOT0_PAGE_CNT_PER_COPY_2 % pages_per_block)
		blocks_per_copy++;

	start_block = blocks_per_copy * counter;
	if ((start_block + blocks_per_copy) > NAND_BOOT0_BLK_CNT) {
		return 0;
	}

	PHY_DBG("boot0 count %d!\n", counter);

	count = 0;
	for (i = start_block; i < (start_block + blocks_per_copy); i++) {
		lnpo.chip  = 0;
		lnpo.block = i;
		lnpo.page  = 0;
		nand_wait_all_rb_ready();

		ret = nci->nand_physic_erase_block(&lnpo);
		if (ret) {
			PHY_ERR("Fail in erasing block %d!\n", lnpo.block);
			//return ret;
		}

		for (j = 0; j < pages_per_block; j++) {
			lnpo.page  = j;
			lnpo.sdata = oob_buf;
			lnpo.slen  = 64;

			lnpo.mdata = (__u8 *)(buf + 1024 * count);

			nand_wait_all_rb_ready();
			if (nci->nand_write_boot0_page(nci, &lnpo) != 0) {
				PHY_ERR("Warning. Fail in writing page %d in block %d.\n",
					lnpo.page, lnpo.block);
			}
			count++;
			if (count == len / 1024) {
				count = 0;
			}
		}
	}

	return 0;

error:

	return -1;
}

int m0_write_boot0_one_nonsecure(unsigned char *buf, unsigned int len,
				 unsigned int counter)
{
	struct _nand_chip_info *nci;
	__u32 lsb_type = 0;

	nci      = g_nctri->nci;
	lsb_type = (nci->npi->operation_opt >> 12) & 0xff;

	PRINT("m0 write boot0 one nonsecure\n");

	if (lsb_type != 0)
		m0_write_boot0_one_pagetab_nonsecure(buf, len, counter);
	else
		m0_write_boot0_one_1k_mode(buf, len, counter);
	return 0;
}

int m0_write_boot0_one_secure(unsigned char *buf, unsigned int len,
			      unsigned int counter)
{
	struct _nand_chip_info *nci;
	__u32 lsb_type = 0;

	nci      = g_nctri->nci;
	lsb_type = (nci->npi->operation_opt >> 12) & 0xff;

	PRINT("m0 write boot0 one secure\n");
	if (lsb_type != 0)
		return (m0_write_boot0_one_pagetab_4k(buf, len, counter));
	else
		return (m0_write_boot0_one_1k_mode(buf, len, counter));

	return -1;
}

/*****************************************************************************
 *Name         :
 *Description  :
 *Parameter    :
 *Return       : 0:ok  -1:fail
 *Note         :
 *****************************************************************************/
int m0_write_boot0_one(unsigned char *buf, unsigned int len,
		       unsigned int counter)
{
	PRINT("m0 write boot0 one\n");

	if (NAND_IS_Secure_sys() == 0)
		return (m0_write_boot0_one_nonsecure(buf, len, counter));
	else if (NAND_IS_Secure_sys() == 1)
		return (m0_write_boot0_one_secure(buf, len, counter));
	PRINT("secure mode judge error\n");
	return -1;
}
