/*
 * Generated by erpcgen 1.8.1 on Sat Jun 19 16:25:06 2021.
 *
 * AUTOGENERATED - DO NOT EDIT
 */


#include "sunxi_amp.h"

#include "demo.h"

//! @brief Function to write struct binary_t
static void write_binary_t_struct(MsgBuf *msgBuffer, const binary_t *data);


// Write struct binary_t function implementation
static void write_binary_t_struct(MsgBuf *msgBuffer, const binary_t *data)
{
    if (!msgBuffer || !data)
    {
        return NULL;
    }
    writeBinary(msgBuffer, data->dataLength, data->data);
}


//! @brief Function to read struct binary_t
static void read_binary_t_struct(MsgBuf *msgBuffer, binary_t *data);


// Read struct binary_t function implementation
static void read_binary_t_struct(MsgBuf *msgBuffer, binary_t *data)
{
    if (!msgBuffer || !data)
    {
        return NULL;
    }
    uint8_t *data_local;
    readBinary(msgBuffer, &data->dataLength, &data_local);
    data->data = (uint8_t *) amp_malloc(data->dataLength * sizeof(uint8_t));
    if (data->data == NULL)
    {
        updateStatus(msgBuffer, kErpcStatus_MemoryError);
    }
    else
    {
        memcpy(data->data, data_local, data->dataLength);
    }
}



// DEMO interface demo1 function client shim.
binary_t *demo1(const binary_t *txInput)
{
    erpc_status_t err = kErpcStatus_Success;

    binary_t *result = NULL;

    MsgBuf *msgBuffer = NULL;
    MsgBuf *sendBuffer = NULL;
    MsgBuf *recvBuffer = NULL;
    MsgBufHeader *header = NULL;

    sendBuffer = msg_buf_create();
    if (!sendBuffer)
    {
        amp_err("alloc buffer failed!\n");
        return result;
    }

    msgBuffer = sendBuffer;
    // Encode the request.

    if (msgBuffer == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        write_binary_t_struct(msgBuffer, txInput);

        // Send message to server
        recvBuffer = func_stub_test(RPCCALL_DEMO(demo1), msgBuffer, 1, 1, NULL);
        if (!recvBuffer)
        {
            msg_buf_destroy(sendBuffer);
            return result;
        }
        msgBuffer = recvBuffer;

        result = (binary_t *) amp_malloc(sizeof(binary_t));
        if (result == NULL)
        {
            updateStatus(msgBuffer, kErpcStatus_MemoryError);
        }
        read_binary_t_struct(msgBuffer, result);
    }

    msg_buf_destroy(sendBuffer);

    header = (MsgBufHeader *)(recvBuffer->data);
    remote_serial_func_call_free_buffer(&header->msg, recvBuffer);

    msg_buf_deinit(recvBuffer);

    return result;
}

// DEMO interface demo2 function client shim.
lockErrors_t demo2(const binary_t *txInput, binary_t *txOutput)
{
    erpc_status_t err = kErpcStatus_Success;

    lockErrors_t result;

    MsgBuf *msgBuffer = NULL;
    MsgBuf *sendBuffer = NULL;
    MsgBuf *recvBuffer = NULL;
    MsgBufHeader *header = NULL;

    sendBuffer = msg_buf_create();
    if (!sendBuffer)
    {
        amp_err("alloc buffer failed!\n");
        return -1;
    }

    msgBuffer = sendBuffer;
    // Encode the request.

    if (msgBuffer == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        write_binary_t_struct(msgBuffer, txInput);

        // Send message to server
        recvBuffer = func_stub_test(RPCCALL_DEMO(demo2), msgBuffer, 1, 2, NULL);
        if (!recvBuffer)
        {
            msg_buf_destroy(sendBuffer);
            return -1;
        }
        msgBuffer = recvBuffer;

        int32_t _tmp_local;

        read_binary_t_struct(msgBuffer, txOutput);

        msgBuffer->read(msgBuffer, &_tmp_local, sizeof(_tmp_local));
        result = (lockErrors_t)(_tmp_local);
    }

    msg_buf_destroy(sendBuffer);

    header = (MsgBufHeader *)(recvBuffer->data);
    remote_serial_func_call_free_buffer(&header->msg, recvBuffer);

    msg_buf_deinit(recvBuffer);

    if (err != kErpcStatus_Success)
    {
        result = (lockErrors_t) -1;
    }

    return result;
}

// DEMO interface demo3 function client shim.
lockErrors_t demo3(const binary_t *txInput, int8_t txOutput[64], int32_t *size)
{
    erpc_status_t err = kErpcStatus_Success;

    lockErrors_t result;

    MsgBuf *msgBuffer = NULL;
    MsgBuf *sendBuffer = NULL;
    MsgBuf *recvBuffer = NULL;
    MsgBufHeader *header = NULL;

    sendBuffer = msg_buf_create();
    if (!sendBuffer)
    {
        amp_err("alloc buffer failed!\n");
        return -1;
    }

    msgBuffer = sendBuffer;
    // Encode the request.

    if (msgBuffer == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        write_binary_t_struct(msgBuffer, txInput);

        // Send message to server
        recvBuffer = func_stub_test(RPCCALL_DEMO(demo3), msgBuffer, 1, 3, NULL);
        if (!recvBuffer)
        {
            msg_buf_destroy(sendBuffer);
            return -1;
        }
        msgBuffer = recvBuffer;

        int32_t _tmp_local;

        for (uint32_t arrayCount0 = 0U; arrayCount0 < 64U; ++arrayCount0)
        {
            msgBuffer->read(msgBuffer, &txOutput[arrayCount0], sizeof(txOutput[arrayCount0]));
        }

        msgBuffer->read(msgBuffer, size, sizeof(*size));

        msgBuffer->read(msgBuffer, &_tmp_local, sizeof(_tmp_local));
        result = (lockErrors_t)(_tmp_local);
    }

    msg_buf_destroy(sendBuffer);

    header = (MsgBufHeader *)(recvBuffer->data);
    remote_serial_func_call_free_buffer(&header->msg, recvBuffer);

    msg_buf_deinit(recvBuffer);

    if (err != kErpcStatus_Success)
    {
        result = (lockErrors_t) -1;
    }

    return result;
}
