/*
 * Generated by erpcgen 1.8.1 on Fri Jun 11 19:08:28 2021.
 *
 * AUTOGENERATED - DO NOT EDIT
 */


#include "sunxi_amp.h"
#include "demo_service.h"
#include "demo.h"

//! @brief Function to read struct binary_t
static void read_binary_t_struct(MsgBuf *msgBuffer, binary_t *data);


// Read struct binary_t function implementation
static void read_binary_t_struct(MsgBuf *msgBuffer, binary_t *data)
{
    if (!msgBuffer || !data)
    {
        return NULL;
    }
    uint8_t *data_local;
    readBinary(msgBuffer, &data->dataLength, &data_local);
    data->data = (uint8_t *) amp_malloc(data->dataLength * sizeof(uint8_t));
    if (data->data == NULL)
    {
        updateStatus(msgBuffer, kErpcStatus_MemoryError);
    }
    else
    {
        memcpy(data->data, data_local, data->dataLength);
    }
}


//! @brief Function to write struct binary_t
static void write_binary_t_struct(MsgBuf *msgBuffer, const binary_t *data);


// Write struct binary_t function implementation
static void write_binary_t_struct(MsgBuf *msgBuffer, const binary_t *data)
{
    if (!msgBuffer || !data)
    {
        return NULL;
    }
    writeBinary(msgBuffer, data->dataLength, data->data);
}


//! @brief Function to free space allocated inside struct binary_t
static void free_binary_t_struct(binary_t *data);


// Free space allocated inside struct binary_t function implementation
static void free_binary_t_struct(binary_t *data)
{
    if (data->data)
    {
        amp_free(data->data);
    }
}

binary_t *demo1(const binary_t *txInput)
{
    printf("txInput->data=%s\n", txInput->data);
    binary_t *ret = malloc(sizeof(binary_t));
    char *buffer = "demo1\n";
    ret->data = malloc(strlen(buffer) + 1);
    memset(ret->data, 0, strlen(buffer) + 1);
    memcpy(ret->data, buffer, strlen(buffer) + 1);
    ret->dataLength = strlen(buffer) + 1;
    return ret;
}

lockErrors_t demo2(const binary_t *txInput, binary_t *txOutput)
{
    printf("demo2 txInput->data=%s\n", txInput->data);
    return 0;
}

lockErrors_t demo3(const binary_t *txInput, int8_t txOutput[64], int32_t *size)
{
    printf("demo3 txInput->data=%s\n", txInput->data);
    return 0;
}

// Server shim for demo1 of DEMO interface.
erpc_status_t demo1_shim(sunxi_amp_msg *msg, MsgBuf *recvBuffer, MsgBuf **sendBuffer)
{
    erpc_status_t err = kErpcStatus_Success;

    MsgBuf *msgBuffer = NULL;
    MsgBufHeader *header = NULL;

    msgBuffer = recvBuffer;

    binary_t *txInput = NULL;
    txInput = (binary_t *) amp_malloc(sizeof(binary_t));
    if (txInput == NULL)
    {
        updateStatus(msgBuffer, kErpcStatus_MemoryError);
    }
    binary_t *result = NULL;


    read_binary_t_struct(msgBuffer, txInput);

    err = msgBuffer->getStatus(msgBuffer);
    if (err == kErpcStatus_Success)
    {
        result = demo1(txInput);

        // preparing MessageBuffer for serializing data
        *sendBuffer = msg_buf_create();
        if (!*sendBuffer)
        {
            amp_err("create send buffer failed!\n");
            return -1;
        }
        msgBuffer = *sendBuffer;
    }

    if (err == kErpcStatus_Success)
    {

        write_binary_t_struct(msgBuffer, result);

        err = msgBuffer->getStatus(msgBuffer);
    }

    if (txInput)
    {
        free_binary_t_struct(txInput);
    }
    if (txInput)
    {
        amp_free(txInput);
    }

    if (result)
    {
        free_binary_t_struct(result);
    }
    if (result)
    {
        amp_free(result);
    }

    return err;
}

// Server shim for demo2 of DEMO interface.
erpc_status_t demo2_shim(sunxi_amp_msg *msg, MsgBuf *recvBuffer, MsgBuf **sendBuffer)
{
    erpc_status_t err = kErpcStatus_Success;

    MsgBuf *msgBuffer = NULL;
    MsgBufHeader *header = NULL;

    msgBuffer = recvBuffer;

    binary_t *txInput = NULL;
    txInput = (binary_t *) amp_malloc(sizeof(binary_t));
    if (txInput == NULL)
    {
        updateStatus(msgBuffer, kErpcStatus_MemoryError);
    }
    binary_t *txOutput = NULL;
    lockErrors_t result;


    read_binary_t_struct(msgBuffer, txInput);

    txOutput = (binary_t *) amp_malloc(sizeof(binary_t));
    if (txOutput == NULL)
    {
        updateStatus(msgBuffer, kErpcStatus_MemoryError);
    }

    err = msgBuffer->getStatus(msgBuffer);
    if (err == kErpcStatus_Success)
    {
        result = demo2(txInput, txOutput);

        // preparing MessageBuffer for serializing data
        *sendBuffer = msg_buf_create();
        if (!*sendBuffer)
        {
            amp_err("create send buffer failed!\n");
            return -1;
        }
        msgBuffer = *sendBuffer;
    }

    if (err == kErpcStatus_Success)
    {

        write_binary_t_struct(msgBuffer, txOutput);

        msgBuffer->write(msgBuffer, (int32_t)(&result), sizeof(uint32_t));

        err = msgBuffer->getStatus(msgBuffer);
    }

    if (txInput)
    {
        free_binary_t_struct(txInput);
    }
    if (txInput)
    {
        amp_free(txInput);
    }

    if (txOutput)
    {
        free_binary_t_struct(txOutput);
    }
    if (txOutput)
    {
        amp_free(txOutput);
    }

    return err;
}

// Server shim for demo3 of DEMO interface.
erpc_status_t demo3_shim(sunxi_amp_msg *msg, MsgBuf *recvBuffer, MsgBuf **sendBuffer)
{
    erpc_status_t err = kErpcStatus_Success;

    MsgBuf *msgBuffer = NULL;
    MsgBufHeader *header = NULL;

    msgBuffer = recvBuffer;

    binary_t *txInput = NULL;
    txInput = (binary_t *) amp_malloc(sizeof(binary_t));
    if (txInput == NULL)
    {
        updateStatus(msgBuffer, kErpcStatus_MemoryError);
    }
    int8_t txOutput[64];
    int32_t size;
    lockErrors_t result;


    read_binary_t_struct(msgBuffer, txInput);

    err = msgBuffer->getStatus(msgBuffer);
    if (err == kErpcStatus_Success)
    {
        result = demo3(txInput, txOutput, &size);

        // preparing MessageBuffer for serializing data
        *sendBuffer = msg_buf_create();
        if (!*sendBuffer)
        {
            amp_err("create send buffer failed!\n");
            return -1;
        }
        msgBuffer = *sendBuffer;
    }

    if (err == kErpcStatus_Success)
    {

        for (uint32_t arrayCount0 = 0U; arrayCount0 < 64U; ++arrayCount0)
        {
            msgBuffer->write(msgBuffer, &txOutput[arrayCount0], sizeof(txOutput[arrayCount0]));
        }

        msgBuffer->write(msgBuffer, &size, sizeof(size));

        msgBuffer->write(msgBuffer, (int32_t)(&result), sizeof(uint32_t));

        err = msgBuffer->getStatus(msgBuffer);
    }

    if (txInput)
    {
        free_binary_t_struct(txInput);
    }
    if (txInput)
    {
        amp_free(txInput);
    }

    return err;
}

sunxi_amp_func_table DEMO_table[] =
{
    {.func = &demo1_shim, .args_num = 1, .return_type = RET_POINTER},
    {.func = &demo2_shim, .args_num = 2, .return_type = RET_POINTER},
    {.func = &demo3_shim, .args_num = 3, .return_type = RET_POINTER},
};

